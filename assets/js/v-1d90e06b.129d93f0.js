"use strict";(self.webpackChunkcs_guide=self.webpackChunkcs_guide||[]).push([[38046],{75316:(e,n,t)=>{t.r(n),t.d(n,{data:()=>i});const i=JSON.parse('{"key":"v-1d90e06b","path":"/java-tutor/stackoverflow/difference-between-wait-and-sleep.html","title":"wait()和sleep()的区别","lang":"zh-CN","frontmatter":{"summary":"wait()和sleep()的区别 问题 在线程里 wait() 和 sleep() 的区别？ 我的理解是执行 wait() 语句后，该线程仍是运行态，并且会占用CPU，但是执行 sleep()后，该线程则不会占用CPU，对吗？ 为什么需要 sleep() 和 wait() 两条语句：他们底层是如何实现的？ 回答 线程 在wait 后，可以被另一个拥有相同 ","head":[["meta",{"property":"og:url","content":"https://yzqdev.github.io/cs-guide/cs-guide/java-tutor/stackoverflow/difference-between-wait-and-sleep.html"}],["meta",{"property":"og:site_name","content":"cs-guide"}],["meta",{"property":"og:title","content":"wait()和sleep()的区别"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-03-22T11:07:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2022-03-22T11:07:21.000Z"}]]},"excerpt":"","headers":[{"level":3,"title":"问题","slug":"问题","children":[]},{"level":3,"title":"回答","slug":"回答","children":[]},{"level":3,"title":"相关问题及链接","slug":"相关问题及链接","children":[]}],"git":{"createdTime":1647947241000,"updatedTime":1647947241000,"contributors":[{"name":"yzqdev","email":"yzqdev@outlook.com","commits":1}]},"readingTime":{"minutes":2.41,"words":722},"filePathRelative":"java-tutor/stackoverflow/difference-between-wait-and-sleep.md","localizedDate":"2022年3月22日"}')},81107:(e,n,t)=>{t.r(n),t.d(n,{default:()=>Q});var i=t(66252);const l=(0,i.uE)('<h1 id="wait-和sleep-的区别" tabindex="-1"><a class="header-anchor" href="#wait-和sleep-的区别" aria-hidden="true">#</a> wait()和sleep()的区别</h1><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h3><p>在线程里 <code>wait()</code> 和 <code>sleep()</code> 的区别？</p><p>我的理解是执行 <code>wait()</code> 语句后，该线程仍是运行态，并且会占用CPU，但是执行 <code>sleep()</code>后，该线程则不会占用CPU，对吗？</p><p>为什么需要 <code>sleep()</code> 和 <code>wait()</code> 两条语句：他们底层是如何实现的？</p><h3 id="回答" tabindex="-1"><a class="header-anchor" href="#回答" aria-hidden="true">#</a> 回答</h3>',6),a=(0,i.Uk)("线程 在"),o={href:"http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#wait%28%29",target:"_blank",rel:"noopener noreferrer"},d=(0,i._)("code",null,"wait",-1),r=(0,i.Uk)(" 后，可以被另一个拥有相同 "),c=(0,i._)("code",null,"synchronized",-1),s=(0,i.Uk)(" 对象的线程，通过调用"),u={href:"http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#notify%28%29",target:"_blank",rel:"noopener noreferrer"},p=(0,i.Uk)("notify"),m=(0,i.Uk)("唤醒，而 "),h=(0,i._)("code",null,"sleep",-1),v=(0,i.Uk)(" 不行。"),f=(0,i._)("code",null,"wait",-1),g=(0,i.Uk)(" 和 "),w=(0,i._)("code",null,"notify",-1),b=(0,i.Uk)(" 能正常执行的条件是（否则会抛异常）：多个线程的代码，都包在"),k=(0,i._)("code",null,"synchronized",-1),y=(0,i.Uk)("块中，并且 "),_=(0,i._)("code",null,"synchronized",-1),U=(0,i.Uk)(" 锁的对象需要是同一个。如下所示："),x=(0,i.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Object mon = ...;\nsynchronized (mon) {\n    mon.wait();\n} \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个线程调用了 <code>wait</code>后，会进入等待状态。这时另外一个线程可以这样做：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>synchronized (mon) { mon.notify(); }\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到，<code>synchronized</code>锁对象，都是mon。因此，当第二个线程调用了 <code>notify()</code> 方法，第一个线程就会唤醒（假设有且仅有一个线程是被包在 <code>synchronized (mon)</code> 中且处于等待状态)。</p>',4),z=(0,i.Uk)("如果有多个线程在等待（且"),j=(0,i._)("code",null,"synchronized",-1),C=(0,i.Uk)(" 锁对象是同一个，如上例中的mon），则可以调用"),O={href:"http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#notifyAll%28%29",target:"_blank",rel:"noopener noreferrer"},q=(0,i.Uk)("notifyAll"),W=(0,i.Uk)("来唤醒。但是，只有其中一个线程能抢到锁并继续执行（因为 "),L=(0,i._)("code",null,"wait",-1),T=(0,i.Uk)(" 的线程都是在 "),K=(0,i._)("code",null,"synchronized",-1),P=(0,i.Uk)(" 块内，需要争夺 "),A=(0,i._)("code",null,"synchronized",-1),E=(0,i.Uk)(" 锁）。其他的线程会被锁住，直到他们依次获得锁。"),N=(0,i.uE)('<p>再补充几点：</p><ul><li><p><code>wait</code> 方法由 <code>Object</code> 对象调用（例如：你可以让 <code>synchronized</code> 锁对象调用 <code>wait</code> ,如上面例子的mon.wait()）,而 <code>sleep</code> 则由线程调用。</p></li><li><p><code>wait</code> 之后，可能会伪唤醒（<code>spurious wakeups</code>）（正在waiting的线程,无故就被唤醒了，如遇到interrupted, timing out等情况）。因此，你需要多设置一些检查，如果不满足实际的运行条件，则继续等待，如下：</p></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>synchronized {\n    while (!condition) { mon.wait(); }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>当线程调用 <code>sleep</code> 时，并没有释放对象锁，而 <code>wait</code> 则释放了对象锁：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>synchronized(LOCK) {\n    Thread.sleep(1000); // LOCK is held\n}\nsynchronized(LOCK) {\n    LOCK.wait(); // LOCK is not held\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，再小结一下：</p><ul><li><code>sleep()</code>:“我已经完成了一个时间片，<strong>在n微秒</strong>前，请不要再给我一个时间片”。这时操作系统不会让这个线程做任何事情，直到sleep时间结束。</li><li><code>wait()</code>:&quot;我已经完成了一个时间片，<strong>在其他线程调用<code>notify()</code>前</strong>，请不要再给我一个时间片）。这时操作系统不会安排这个线程继续运行，直到有人调用了<code>notify()</code></li></ul>',7),Z=(0,i._)("strong",null,"stackoverflow链接：",-1),D={href:"http://stackoverflow.com/questions/1036754/difference-between-wait-and-sleep",target:"_blank",rel:"noopener noreferrer"},J=(0,i.Uk)("http://stackoverflow.com/questions/1036754/difference-between-wait-and-sleep"),I=(0,i._)("h3",{id:"相关问题及链接",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#相关问题及链接","aria-hidden":"true"},"#"),(0,i.Uk)(" 相关问题及链接")],-1),R={href:"http://stackoverflow.com/questions/37026/java-notify-vs-notifyall-all-over-again",target:"_blank",rel:"noopener noreferrer"},S=(0,i.Uk)("Java: notify() vs. notifyAll() all over again"),B={href:"http://ifeve.com/thread-signaling/",target:"_blank",rel:"noopener noreferrer"},F=(0,i.Uk)("线程通信"),G={href:"http://longdick.iteye.com/blog/453615",target:"_blank",rel:"noopener noreferrer"},H=(0,i.Uk)("最简实例说明wait、notify、notifyAll的使用方法"),M={},Q=(0,t(83744).Z)(M,[["render",function(e,n){const t=(0,i.up)("ExternalLinkIcon");return(0,i.wg)(),(0,i.iD)("div",null,[l,(0,i._)("p",null,[a,(0,i._)("a",o,[d,(0,i.Wm)(t)]),r,c,s,(0,i._)("a",u,[p,(0,i.Wm)(t)]),m,h,v,f,g,w,b,k,y,_,U]),x,(0,i._)("p",null,[z,j,C,(0,i._)("a",O,[q,(0,i.Wm)(t)]),W,L,T,K,P,A,E]),N,(0,i._)("p",null,[Z,(0,i._)("a",D,[J,(0,i.Wm)(t)])]),I,(0,i._)("ol",null,[(0,i._)("li",null,[(0,i._)("a",R,[S,(0,i.Wm)(t)])]),(0,i._)("li",null,[(0,i._)("a",B,[F,(0,i.Wm)(t)])]),(0,i._)("li",null,[(0,i._)("a",G,[H,(0,i.Wm)(t)])])])])}]])}}]);