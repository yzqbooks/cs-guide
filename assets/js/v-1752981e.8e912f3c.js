"use strict";(self.webpackChunkcs_guide=self.webpackChunkcs_guide||[]).push([[36085],{60902:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t=JSON.parse('{"key":"v-1752981e","path":"/frontend/basic-js/es/async,await.html","title":"js中的异步","lang":"zh-CN","frontmatter":{"summary":"js中的异步 Chrome 55 中默认情况下启用异步函数，坦率地讲，它们的作用相当不可思议。 可以利用它们像编写同步代码那样编写基于 Promise 的代码，而且还不会阻塞主线程。 它们可以让异步代码“智商”下降、可读性提高。 异步函数的工作方式是这样的: 如果在函数定义之前使用了 async 关键字，就可以在函数内使用 await。 当您 await 某","head":[["meta",{"property":"og:url","content":"https://yzqdev.github.io/cs-guide/cs-guide/frontend/basic-js/es/async,await.html"}],["meta",{"property":"og:site_name","content":"cs-guide"}],["meta",{"property":"og:title","content":"js中的异步"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-07-25T14:57:57.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2022-07-25T14:57:57.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"示例: 记录获取日志","slug":"示例-记录获取日志","children":[]},{"level":2,"title":"异步函数返回值","slug":"异步函数返回值","children":[]},{"level":2,"title":"示例: 流式传输响应","slug":"示例-流式传输响应","children":[]},{"level":2,"title":"其他异步函数语法","slug":"其他异步函数语法","children":[{"level":3,"title":"箭头函数","slug":"箭头函数","children":[]},{"level":3,"title":"对象方法","slug":"对象方法","children":[]},{"level":3,"title":"类方法","slug":"类方法","children":[]}]},{"level":2,"title":"注意！避免太过循序","slug":"注意-避免太过循序","children":[{"level":3,"title":"示例: 按顺序输出获取的数据","slug":"示例-按顺序输出获取的数据","children":[]}]},{"level":2,"title":"浏览器支持与解决方法","slug":"浏览器支持与解决方法","children":[{"level":3,"title":"解决方法 - 生成器","slug":"解决方法-生成器","children":[]},{"level":3,"title":"解决方法 - 再生器","slug":"解决方法-再生器","children":[]}]},{"level":2,"title":"全面异步化","slug":"全面异步化","children":[]}],"git":{"createdTime":1658761077000,"updatedTime":1658761077000,"contributors":[{"name":"yzqdev","email":"yzqdev@outlook.com","commits":1}]},"readingTime":{"minutes":7.1,"words":2130},"filePathRelative":"frontend/basic-js/es/async,await.md","localizedDate":"2022年7月25日"}')},48045:(n,s,a)=>{a.r(s),a.d(s,{default:()=>yn});var t=a(66252);const e=(0,t.uE)('<h1 id="js中的异步" tabindex="-1"><a class="header-anchor" href="#js中的异步" aria-hidden="true">#</a> js中的异步</h1><p>Chrome 55 中默认情况下启用异步函数，坦率地讲，它们的作用相当不可思议。 可以利用它们像编写同步代码那样编写基于 Promise 的代码，而且还不会阻塞主线程。 它们可以让异步代码“智商”下降、可读性提高。</p><p>异步函数的工作方式是这样的:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">myFirstAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> fulfilledValue <span class="token operator">=</span> <span class="token keyword">await</span> promise<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">catch</span> <span class="token punctuation">(</span>rejectedValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// …</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在函数定义之前使用了 <code>async</code> 关键字，就可以在函数内使用 <code>await</code>。 当您 <code>await</code> 某个 Promise 时，函数暂停执行，直至该 Promise 产生结果，并且暂停并不会阻塞主线程。 如果 Promise 执行，则会返回值。 如果 Promise 拒绝，则会抛出拒绝的值。</p>',5),p=(0,t._)("strong",null,"Note:",-1),o=(0,t.Uk)(" 如果不熟悉 Promise，可以看一看"),c={href:"https://developers.google.cn/web/fundamentals/getting-started/primers/promises",target:"_blank",rel:"noopener noreferrer"},l=(0,t.Uk)("我们的 Promise 指南"),i=(0,t.Uk)("。"),u=(0,t.uE)('<h2 id="示例-记录获取日志" tabindex="-1"><a class="header-anchor" href="#示例-记录获取日志" aria-hidden="true">#</a> 示例: 记录获取日志</h2><p>假设我们想获取某个网址并以文本形式记录响应日志。以下是利用 Promise 编写的代码:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">logFetch</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">text</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;fetch failed&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下是利用异步函数具有相同作用的代码:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">logFetch</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;fetch failed&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码行数虽然相同，但去掉了所有回调。这可以提高代码的可读性，对不太熟悉 Promise 的人而言，帮助就更大了。</p><p><strong>Note:</strong> 您 <code>await</code> 的任何内容都通过 <code>Promise.resolve()</code> 传递，这样您就可以安全地 <code>await</code> 非原生 Promise。</p><h2 id="异步函数返回值" tabindex="-1"><a class="header-anchor" href="#异步函数返回值" aria-hidden="true">#</a> 异步函数返回值</h2><p>无论是否使用 <code>await</code>，异步函数_都会_返回 Promise。该 Promise 解析时返回异步函数返回的任何值，拒绝时返回异步函数抛出的任何值。</p><p>因此，对于:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// wait ms milliseconds</span>\n<span class="token keyword">function</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token parameter">ms</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">await</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token string">&#39;world&#39;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>…调用 <code>hello()</code> 返回的 Promise 会在_执行_时返回 <code>&quot;world&quot;</code>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">await</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">&#39;bar&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>…调用 <code>foo()</code> 返回的 Promise 会在_拒绝_时返回 <code>Error(&#39;bar&#39;)</code>。</p><h2 id="示例-流式传输响应" tabindex="-1"><a class="header-anchor" href="#示例-流式传输响应" aria-hidden="true">#</a> 示例: 流式传输响应</h2><p>异步函数在更复杂示例中更有用武之地。假设我们想在流式传输响应的同时记录数据块日志，并返回数据块最终大小。</p><p><strong>Note:</strong> 一看到“记录数据块日志”这几个字就让我感到不舒服。</p><p>以下是使用 Promise 编写的代码:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getResponseSize</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> reader <span class="token operator">=</span> response<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">getReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">processResult</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">return</span> total<span class="token punctuation">;</span>\n\n      <span class="token keyword">const</span> value <span class="token operator">=</span> result<span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n      total <span class="token operator">+=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Received chunk&#39;</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">return</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>processResult<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请“Promise 大师”Jake Archibald 给我检查一下。看到我是如何在 <code>processResult</code> 内调用其自身来建立异步循环了吧？ 这样编写的代码让我觉得_很智能_。 但就像大多数“智能”代码那样，你得盯着它看上半天才能弄明白它的作用，要拿出揣摩上世纪 90 年代流行的魔眼图片的那种劲头才行。</p><p>我们再用异步函数来编写上面这段代码:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getResponseSize</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> reader <span class="token operator">=</span> response<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">getReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> value <span class="token operator">=</span> result<span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n    total <span class="token operator">+=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Received chunk&#39;</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// get the next result</span>\n    result <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> total<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',22),r=(0,t.Uk)("所有“智能”都不见了。让我大有飘飘然之感的异步循环被替换成可靠却单调乏味的 while 循环。 但简明性得到大幅提高。未来，我们将获得"),k={href:"https://github.com/tc39/proposal-async-iteration",target:"_blank",rel:"noopener noreferrer"},d=(0,t.Uk)("异步迭代器"),v=(0,t.Uk)("，这些迭代器"),m={href:"https://gist.github.com/jakearchibald/0b37865637daf884943cf88c2cba1376",target:"_blank",rel:"noopener noreferrer"},b=(0,t.Uk)("会将 "),h=(0,t._)("code",null,"while",-1),g=(0,t.Uk)(" 循环替换成 for-of 循环"),f=(0,t.Uk)("，从而进一步提高代码的简明性。"),w=(0,t._)("strong",null,"Note:",-1),y=(0,t.Uk)(" 我有点偏爱卡片信息流。如果不熟悉流式传输，可以"),_={href:"https://jakearchibald.com/2016/streams-ftw/#streams-the-fetch-api",target:"_blank",rel:"noopener noreferrer"},j=(0,t.Uk)("看一看我的指南"),x=(0,t.Uk)("。"),U=(0,t.uE)('<h2 id="其他异步函数语法" tabindex="-1"><a class="header-anchor" href="#其他异步函数语法" aria-hidden="true">#</a> 其他异步函数语法</h2><p>我们已经见识了 <code>async function() {}</code>，但 <code>async</code> 关键字还可用于其他函数语法:</p><h3 id="箭头函数" tabindex="-1"><a class="header-anchor" href="#箭头函数" aria-hidden="true">#</a> 箭头函数</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// map some URLs to json-promises</span>\n<span class="token keyword">const</span> jsonPromises <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token parameter">url</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Note:</strong> <code>array.map(func)</code> 不在乎我提供给它的是不是异步函数，只把它当作一个返回 Promise 的函数来看待。 它不会等到第一个函数执行完毕就会调用第二个函数。</p><h3 id="对象方法" tabindex="-1"><a class="header-anchor" href="#对象方法" aria-hidden="true">#</a> 对象方法</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> storage <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">getAvatar</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">await</span> caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&#39;avatars&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/avatars/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.jpg</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nstorage<span class="token punctuation">.</span><span class="token function">getAvatar</span><span class="token punctuation">(</span><span class="token string">&#39;jaffathecake&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类方法" tabindex="-1"><a class="header-anchor" href="#类方法" aria-hidden="true">#</a> 类方法</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>cachePromise <span class="token operator">=</span> caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&#39;avatars&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">async</span> <span class="token function">getAvatar</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cachePromise<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/avatars/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.jpg</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nstorage<span class="token punctuation">.</span><span class="token function">getAvatar</span><span class="token punctuation">(</span><span class="token string">&#39;jaffathecake&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Note:</strong> 类构造函数以及 getter/settings 方法不能是异步的。</p><h2 id="注意-避免太过循序" tabindex="-1"><a class="header-anchor" href="#注意-避免太过循序" aria-hidden="true">#</a> 注意！避免太过循序</h2><p>尽管您编写的是看似同步的代码，也一定不要错失并行执行的机会。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">series</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">await</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">await</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token string">&quot;done!&quot;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码执行完毕需要 1000 毫秒，再看看这段代码:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> wait1 <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> wait2 <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">await</span> wait1<span class="token punctuation">;</span>\n  <span class="token keyword">await</span> wait2<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token string">&quot;done!&quot;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>…以上代码只需 500 毫秒就可执行完毕，因为两个 wait 是同时发生的。让我们看一个实例…</p><h3 id="示例-按顺序输出获取的数据" tabindex="-1"><a class="header-anchor" href="#示例-按顺序输出获取的数据" aria-hidden="true">#</a> 示例: 按顺序输出获取的数据</h3><p>假定我们想获取一系列网址，并尽快按正确顺序将它们记录到日志中。</p><p><em>深呼吸</em> - 以下是使用 Promise 编写的代码:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">logInOrder</span><span class="token punctuation">(</span><span class="token parameter">urls</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// fetch all the URLs</span>\n  <span class="token keyword">const</span> textPromises <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">url</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// log them in order</span>\n  textPromises<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">chain<span class="token punctuation">,</span> textPromise</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> textPromise<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">text</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是的，没错，我使用 <code>reduce</code> 来链接 Promise 序列。我是不是_很智能_。 但这种有点_很智能_的编码还是不要为好。</p><p>不过，如果使用异步函数改写以上代码，又容易让代码变得_过于循序_:</p><p><strong>不推荐的编码方式</strong> - 过于循序</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">logInOrder</span><span class="token punctuation">(</span><span class="token parameter">urls</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> url <span class="token keyword">of</span> urls<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码简洁得多，但我的第二次获取要等到第一次获取读取完毕才能开始，以此类推。 其执行效率要比并行执行获取的 Promise 示例低得多。 幸运的是，还有一种理想的中庸之道:</p><p><strong>推荐的编码方式</strong> - 可读性强、并行效率高</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">logInOrder</span><span class="token punctuation">(</span><span class="token parameter">urls</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// fetch all the URLs in parallel</span>\n  <span class="token keyword">const</span> textPromises <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token parameter">url</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// log them in sequence</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> textPromise <span class="token keyword">of</span> textPromises<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> textPromise<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在本例中，以并行方式获取和读取网址，但将“智能”的 <code>reduce</code> 部分替换成标准单调乏味但可读性强的 for 循环。</p><h2 id="浏览器支持与解决方法" tabindex="-1"><a class="header-anchor" href="#浏览器支持与解决方法" aria-hidden="true">#</a> 浏览器支持与解决方法</h2><p>在写作本文时，Chrome 55 中默认情况下启用异步函数，但它们在所有主流浏览器中正处于开发阶段:</p>',30),P=(0,t.Uk)("Edge - "),W={href:"https://developer.microsoft.com/en-us/microsoft-edge/platform/status/asyncfunctions/",target:"_blank",rel:"noopener noreferrer"},R=(0,t.Uk)("在 14342+ 编译版本中隐藏在一个标志后"),E=(0,t.Uk)("Firefox - "),q={href:"https://bugzilla.mozilla.org/show_bug.cgi?id=1185106",target:"_blank",rel:"noopener noreferrer"},z=(0,t.Uk)("开发中"),N=(0,t.Uk)("Safari - "),A={href:"https://bugs.webkit.org/show_bug.cgi?id=156147",target:"_blank",rel:"noopener noreferrer"},C=(0,t.Uk)("开发中"),B=(0,t._)("h3",{id:"解决方法-生成器",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#解决方法-生成器","aria-hidden":"true"},"#"),(0,t.Uk)(" 解决方法 - 生成器")],-1),F=(0,t.Uk)("如果目标是支持生成器的浏览器（其中包括"),S={href:"http://kangax.github.io/compat-table/es6/#test-generators",target:"_blank",rel:"noopener noreferrer"},L=(0,t.Uk)("每一个主流浏览器的最新版本"),T=(0,t.Uk)("），可以通过 polyfill 使用异步函数。"),I={href:"https://babeljs.io/",target:"_blank",rel:"noopener noreferrer"},O=(0,t.Uk)("Babel"),V=(0,t.Uk)(" 可以为您实现此目的，"),Z={href:"https://goo.gl/0Cg1Sq",target:"_blank",rel:"noopener noreferrer"},D=(0,t.Uk)("以下是通过 Babel REPL 实现的示例"),J=(0,t.Uk)("注意到转译的代码有多相似了吧。这一转换是 "),$={href:"http://babeljs.io/docs/plugins/preset-es2017/",target:"_blank",rel:"noopener noreferrer"},X=(0,t.Uk)("Babel es2017 预设"),G=(0,t.Uk)("的一部分。"),H=(0,t._)("p",null,[(0,t._)("strong",null,"Note:"),(0,t.Uk)(" Babel REPL 说起来很有趣。试试就知道。")],-1),K=(0,t.Uk)("我建议采用转译方法，因为目标浏览器支持异步函数后，直接将其关闭即可，但如果_实在_不想使用转译器，可以亲自试用一下 "),M={href:"https://gist.github.com/jakearchibald/edbc78f73f7df4f7f3182b3c7e522d25",target:"_blank",rel:"noopener noreferrer"},Q=(0,t.Uk)("Babel 的 polyfill"),Y=(0,t.Uk)("。"),nn=(0,t.uE)('<p>原本的异步函数代码:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">slowEcho</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">await</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> val<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',2),sn=(0,t.Uk)("…如果使用 "),an={href:"https://gist.github.com/jakearchibald/edbc78f73f7df4f7f3182b3c7e522d25",target:"_blank",rel:"noopener noreferrer"},tn=(0,t.Uk)("polyfill"),en=(0,t.Uk)("，就需要这样编写:"),pn=(0,t.uE)('<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> slowEcho <span class="token operator">=</span> <span class="token function">createAsyncFunction</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">yield</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> val<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，需要将生成器 (<code>function*</code>) 传递给 <code>createAsyncFunction</code>，并使用 <code>yield</code> 来替代 <code>await</code>。 其他方面的工作方式是相同的。</p><h3 id="解决方法-再生器" tabindex="-1"><a class="header-anchor" href="#解决方法-再生器" aria-hidden="true">#</a> 解决方法 - 再生器</h3>',3),on=(0,t.Uk)("如果目标是旧版浏览器，Babel 还可转译生成器，让您能在版本低至 IE8 的浏览器上使用异步函数。 为此，您需要 "),cn={href:"http://babeljs.io/docs/plugins/preset-es2017/",target:"_blank",rel:"noopener noreferrer"},ln=(0,t.Uk)("Babel 的 es2017 预设"),un=(0,t._)("em",null,"和",-1),rn=(0,t.Uk)(),kn={href:"http://babeljs.io/docs/plugins/preset-es2015/",target:"_blank",rel:"noopener noreferrer"},dn=(0,t.Uk)("es2015 预设"),vn=(0,t.Uk)("。"),mn={href:"https://goo.gl/jlXboV",target:"_blank",rel:"noopener noreferrer"},bn=(0,t.Uk)("输出不够美观"),hn=(0,t.Uk)("，因此要注意避免发生代码膨胀。"),gn=(0,t._)("h2",{id:"全面异步化",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#全面异步化","aria-hidden":"true"},"#"),(0,t.Uk)(" 全面异步化")],-1),fn=(0,t._)("p",null,"一旦异步函数登陆所有浏览器，就在每一个返回 Promise 的函数上尽情使用吧！ 它们不但能让代码更加整洁美观，还能确保该函数_始终_都能返回 Promise。",-1),wn={},yn=(0,a(83744).Z)(wn,[["render",function(n,s){const a=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)("div",null,[e,(0,t._)("p",null,[p,o,(0,t._)("a",c,[l,(0,t.Wm)(a)]),i]),u,(0,t._)("p",null,[r,(0,t._)("a",k,[d,(0,t.Wm)(a)]),v,(0,t._)("a",m,[b,h,g,(0,t.Wm)(a)]),f]),(0,t._)("p",null,[w,y,(0,t._)("a",_,[j,(0,t.Wm)(a)]),x]),U,(0,t._)("ul",null,[(0,t._)("li",null,[P,(0,t._)("a",W,[R,(0,t.Wm)(a)])]),(0,t._)("li",null,[E,(0,t._)("a",q,[z,(0,t.Wm)(a)])]),(0,t._)("li",null,[N,(0,t._)("a",A,[C,(0,t.Wm)(a)])])]),B,(0,t._)("p",null,[F,(0,t._)("a",S,[L,(0,t.Wm)(a)]),T]),(0,t._)("p",null,[(0,t._)("a",I,[O,(0,t.Wm)(a)]),V,(0,t._)("a",Z,[D,(0,t.Wm)(a)])]),(0,t._)("ul",null,[(0,t._)("li",null,[J,(0,t._)("a",$,[X,(0,t.Wm)(a)]),G])]),H,(0,t._)("p",null,[K,(0,t._)("a",M,[Q,(0,t.Wm)(a)]),Y]),nn,(0,t._)("p",null,[sn,(0,t._)("a",an,[tn,(0,t.Wm)(a)]),en]),pn,(0,t._)("p",null,[on,(0,t._)("a",cn,[ln,(0,t.Wm)(a)]),un,rn,(0,t._)("a",kn,[dn,(0,t.Wm)(a)]),vn]),(0,t._)("p",null,[(0,t._)("a",mn,[bn,(0,t.Wm)(a)]),hn]),gn,fn])}]])}}]);