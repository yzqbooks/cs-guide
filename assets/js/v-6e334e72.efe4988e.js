"use strict";(self.webpackChunkcs_guide=self.webpackChunkcs_guide||[]).push([[41747],{37661:(e,a,t)=>{t.r(a),t.d(a,{data:()=>r});const r=JSON.parse('{"key":"v-6e334e72","path":"/java-tutor/stackoverflow/what-is-a-javabean-exactly.html","title":"JavaBean 到底是什么？","lang":"zh-CN","frontmatter":{"summary":"JavaBean 到底是什么？ 问题 按照我的理解： “Bean” 是一个带有属性和getters/setter方法的Java类。它是不是和C的结构体是相似的呢，对吗？ 一个“Bean\\"类与普通的类相比是不是语法的不同呢？还是有特殊的定义和接口？ 为什么会出现这个术语呢，这让我很困惑？ 如果你很好心告诉我一些关于Serializable接口的信息，对于你的答","head":[["meta",{"property":"og:url","content":"https://yzqdev.github.io/cs-guide/cs-guide/java-tutor/stackoverflow/what-is-a-javabean-exactly.html"}],["meta",{"property":"og:site_name","content":"cs-guide"}],["meta",{"property":"og:title","content":"JavaBean 到底是什么？"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-03-22T11:07:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2022-03-22T11:07:21.000Z"}]]},"excerpt":"","headers":[{"level":3,"title":"问题","slug":"问题","children":[]},{"level":3,"title":"回答","slug":"回答","children":[]},{"level":3,"title":"关于序列化相关博客","slug":"关于序列化相关博客","children":[]}],"git":{"createdTime":1647947241000,"updatedTime":1647947241000,"contributors":[{"name":"yzqdev","email":"yzqdev@outlook.com","commits":1}]},"readingTime":{"minutes":1.86,"words":557},"filePathRelative":"java-tutor/stackoverflow/what-is-a-javabean-exactly.md","localizedDate":"2022年3月22日"}')},36186:(e,a,t)=>{t.r(a),t.d(a,{default:()=>T});var r=t(66252);const l=(0,r.uE)('<h1 id="javabean-到底是什么" tabindex="-1"><a class="header-anchor" href="#javabean-到底是什么" aria-hidden="true">#</a> JavaBean 到底是什么？</h1><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h3><p>按照我的理解： “Bean” 是一个带有属性和getters/setter方法的Java类。它是不是和C的结构体是相似的呢，对吗？ 一个“Bean&quot;类与普通的类相比是不是语法的不同呢？还是有特殊的定义和接口？ 为什么会出现这个术语呢，这让我很困惑？ 如果你很好心告诉我一些关于<code>Serializable</code>接口的信息，对于你的答案那到底是什么意思，我会非常感谢你的。</p><h3 id="回答" tabindex="-1"><a class="header-anchor" href="#回答" aria-hidden="true">#</a> 回答</h3>',4),n=(0,r.Uk)("JavaBean 只是一个"),i={href:"http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html",target:"_blank",rel:"noopener noreferrer"},o=(0,r.Uk)("标准"),s=(0,r.Uk)("所有的属性是私有的（通过"),c={href:"https://en.wikipedia.org/wiki/Mutator_method",target:"_blank",rel:"noopener noreferrer"},d=(0,r.Uk)("getters/setters"),h=(0,r.Uk)("处理属性）"),u=(0,r._)("li",null,"一个公有的无参数的构造器",-1),v=(0,r.Uk)("实现了"),p={href:"http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html",target:"_blank",rel:"noopener noreferrer"},m=(0,r.Uk)("序列化（Serializable）"),b=(0,r._)("p",null,"就这些，它只是一个规范。但是很多的类库都是依赖于这些预定。",-1),g=(0,r.Uk)("对于"),k=(0,r._)("code",null,"Serializable",-1),_=(0,r.Uk)(",看一下"),f={href:"http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html",target:"_blank",rel:"noopener noreferrer"},w=(0,r.Uk)("API文档的解释"),j=(0,r.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>实现java.io.Serializable接口的类能串行化。\n不实现此接口的类不会有任何状态的序列化和反序列化。\n可序列化类的所有子类型本身都是可序列化。\n序列化接口没有方法或字段，仅用于标识的可序列化的语义。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>换句话说，序列化的对象可以被写入流，文件，对象数据库等。</p><p>另外，一个JavaBean类和一个普通的类没有语法区别，如果遵循上面的标准的话，一个类可以认为成JavaBean类。</p><p>之所以需要JavaBean，是因为这样预定义了一种类的格式，一些库能依据这个约定的格式，来做一些自动化处理。举个例子，如果一个类库需要通过流来处理你传递的任何对象，它知道它可以正常处理，因为这个对象是可序列化的。（假设这个类库要求你的对象是JavaBeans）</p>',4),y=(0,r._)("strong",null,"stackoverflow链接",-1),x=(0,r.Uk)("： "),U={href:"http://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly",target:"_blank",rel:"noopener noreferrer"},z=(0,r.Uk)("http://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly"),J=(0,r._)("h3",{id:"关于序列化相关博客",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#关于序列化相关博客","aria-hidden":"true"},"#"),(0,r.Uk)(" 关于序列化相关博客")],-1),B={href:"http://xiebh.iteye.com/blog/121311",target:"_blank",rel:"noopener noreferrer"},S=(0,r.Uk)("我对Java Serializable（序列化）的理解和总结"),W={href:"http://www.blogjava.net/jiangshachina/archive/2012/02/13/369898.html",target:"_blank",rel:"noopener noreferrer"},q=(0,r.Uk)("理解Java对象序列化"),C={},T=(0,t(83744).Z)(C,[["render",function(e,a){const t=(0,r.up)("ExternalLinkIcon");return(0,r.wg)(),(0,r.iD)("div",null,[l,(0,r._)("p",null,[n,(0,r._)("a",i,[o,(0,r.Wm)(t)])]),(0,r._)("ol",null,[(0,r._)("li",null,[s,(0,r._)("a",c,[d,(0,r.Wm)(t)]),h]),u,(0,r._)("li",null,[v,(0,r._)("a",p,[m,(0,r.Wm)(t)])])]),b,(0,r._)("p",null,[g,k,_,(0,r._)("a",f,[w,(0,r.Wm)(t)])]),j,(0,r._)("p",null,[y,x,(0,r._)("a",U,[z,(0,r.Wm)(t)])]),J,(0,r._)("ol",null,[(0,r._)("li",null,[(0,r._)("a",B,[S,(0,r.Wm)(t)])]),(0,r._)("li",null,[(0,r._)("a",W,[q,(0,r.Wm)(t)])])])])}]])}}]);