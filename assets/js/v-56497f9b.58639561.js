"use strict";(self.webpackChunkcs_guide=self.webpackChunkcs_guide||[]).push([[18981],{22188:(e,t,a)=>{a.r(t),a.d(t,{data:()=>r});const r=JSON.parse('{"key":"v-56497f9b","path":"/linux-tutor/tool/strace.html","title":"strace 跟踪进程中的系统调用","lang":"zh-CN","frontmatter":{"summary":"strace 跟踪进程中的系统调用 strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。 输出参数含义 ","head":[["meta",{"property":"og:url","content":"https://yzqdev.github.io/cs-guide/cs-guide/linux-tutor/tool/strace.html"}],["meta",{"property":"og:site_name","content":"cs-guide"}],["meta",{"property":"og:title","content":"strace 跟踪进程中的系统调用"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-05-27T01:37:35.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2022-05-27T01:37:35.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"输出参数含义","slug":"输出参数含义","children":[]},{"level":2,"title":"参数","slug":"参数","children":[]},{"level":2,"title":"命令实例","slug":"命令实例","children":[{"level":3,"title":"跟踪可执行程序","slug":"跟踪可执行程序","children":[]},{"level":3,"title":"跟踪服务程序","slug":"跟踪服务程序","children":[]}]}],"git":{"createdTime":1653565176000,"updatedTime":1653615455000,"contributors":[{"name":"yzqdev","email":"yzqdev@outlook.com","commits":2}]},"readingTime":{"minutes":4.05,"words":1214},"filePathRelative":"linux-tutor/tool/strace.md","localizedDate":"2022年5月26日"}')},11236:(e,t,a)=>{a.r(t),a.d(t,{default:()=>o});var r=a(66252);const n=[(0,r.uE)('<h1 id="strace-跟踪进程中的系统调用" tabindex="-1"><a class="header-anchor" href="#strace-跟踪进程中的系统调用" aria-hidden="true">#</a> strace 跟踪进程中的系统调用</h1><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><h2 id="输出参数含义" tabindex="-1"><a class="header-anchor" href="#输出参数含义" aria-hidden="true">#</a> 输出参数含义</h2><p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p><pre><code>$strace cat /dev/null \nexecve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;/dev/null&quot;], [/* 22 vars */]) = 0\nbrk(0)                                  = 0xab1000\naccess(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000\naccess(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)\n...\n</code></pre><h2 id="参数" tabindex="-1"><a class="header-anchor" href="#参数" aria-hidden="true">#</a> 参数</h2><pre><code>-c 统计每一系统调用的所执行的时间,次数和出错的次数等. \n-d 输出strace关于标准错误的调试信息. \n-f 跟踪由fork调用所产生的子进程. \n-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. \n-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. \n-h 输出简要的帮助信息. \n-i 输出系统调用的入口指针. \n-q 禁止输出关于脱离的消息. \n-r 打印出相对时间关于,,每一个系统调用. \n-t 在输出中的每一行前加上时间信息. \n-tt 在输出中的每一行前加上时间信息,微秒级. \n-ttt 微秒级输出,以秒了表示时间. \n-T 显示每一调用所耗的时间. \n-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. \n-V 输出strace的版本信息. \n-x 以十六进制形式输出非标准字符串 \n-xx 所有字符串以十六进制形式输出. \n-a column \n设置返回值的输出位置.默认 为40. \n-e expr \n指定一个表达式,用来控制如何跟踪.格式如下: \n[qualifier=][!]value1[,value2]... \nqualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如: \n-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. \n注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\. \n-e trace=set \n只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. \n-e trace=file \n只跟踪有关文件操作的系统调用. \n-e trace=process \n只跟踪有关进程控制的系统调用. \n-e trace=network \n跟踪与网络有关的所有系统调用. \n-e strace=signal \n跟踪所有与系统信号有关的 系统调用 \n-e trace=ipc \n跟踪所有与进程通讯有关的系统调用 \n-e abbrev=set \n设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. \n-e raw=set \n将指 定的系统调用的参数以十六进制显示. \n-e signal=set \n指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. \n-e read=set \n输出从指定文件中读出 的数据.例如: \n-e read=3,5 \n-e write=set \n输出写入到指定文件中的数据. \n-o filename \n将strace的输出写入文件filename \n-p pid \n跟踪指定的进程pid. \n-s strsize \n指定输出的字符串的最大长度.默认为32.文件名一直全部输出. \n-u username \n以username 的UID和GID执行被跟踪的命令\n</code></pre><h2 id="命令实例" tabindex="-1"><a class="header-anchor" href="#命令实例" aria-hidden="true">#</a> 命令实例</h2><h3 id="跟踪可执行程序" tabindex="-1"><a class="header-anchor" href="#跟踪可执行程序" aria-hidden="true">#</a> 跟踪可执行程序</h3><pre><code>strace -f -F -o ~/straceout.txt myserver\n</code></pre><p>-f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p><h3 id="跟踪服务程序" tabindex="-1"><a class="header-anchor" href="#跟踪服务程序" aria-hidden="true">#</a> 跟踪服务程序</h3><pre><code>strace -o output.txt -T -tt -e trace=all -p 28979\n</code></pre><p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>',14)],c={},o=(0,a(83744).Z)(c,[["render",function(e,t){return(0,r.wg)(),(0,r.iD)("div",null,n)}]])}}]);